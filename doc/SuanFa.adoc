= ㍿ 算法吐槽大会
帝八哥<xyb5to0zcy@gmail.com>
v1.0, 2021-04-06
:toc: right

== 数据结构
- 数组
- 链表
- 二叉树
- 跳表
- 图

== 基础算法
- 快速排序
- 归并排序
- 二叉树遍历

.快排.java
[source,java]
----
import java.util.Stack;public class 快排 {

    /**
    * 中轴排序核心
    *
    * @param source
    * @param start
    * @param end
    */
    public static int fftPartition(int[] source, int start, int end) {
        int rv = source[start];
        while(start < end){
            while(source[end] > rv && end > start){
                end--;
            }
            if (end != end){
                source[start] = source[end];
            }
            while (source[start] <= rv && start < end){
                start++;
            }
            if (start != end){
                source[end] = source[start];
            }
        }
        source[start] = rv;
        return start;
    }

    /**
    *
    * @param source
    * @param start
    * @param end
    */
    public static void recursionFFTSort(int[] source, int start, int end){
        if (start >= end){
            return;
        }
        int midRoller = fftPartition(source, start, end);
        recursionFFTSort(source, start, midRoller - 1);
        recursionFFTSort(source, midRoller + 1, end);
    }

    /**
    *
    * @param source
    * @param start
    * @param end
    */
    public static void nonRecursionFFTSort(int[] source, int start, ine end){
        if (start >= end){
            return;
        }
        Stack<Integer> stack = new Stack<>();
        stack.push(end);
        stack.push(start);
        int midRoller;
        while (!stack.isEmpty()){
            start = stack.pop();
            end = stack.pop();
            midRoller = fftPartition(source, start, end);
            if (start < midRoller - 1){
                stack.push(midRoller - 1);
                stack.push(start);
            }

            if (midRoller + 1 < end){
                stack.push(end);
                stack.push(midRoller + 1);
            }
        }
    }

    public static void doMerge(int[] source, int start, int midRoller, int end){
        int[] temp = new int[end - start + 1];
        int i = start;
        int j = midRoller + 1;
        int k = 0;
        // 复制小值
        while (i <= midRoller && j <= end){
            if (source[i] < source[j]){
                temp[k++] = source[i++];
            } else {
                temp[k++] = sour[j++];
            }
        }
        // 复制左边剩余的
        while (i <= midRoller){
            temp[k++] = source[i++];
        }
        // 复制右边剩余的
        while (j <= end){
            temp[k++] = source[j++];
        }
        System.arraycopy(temp, 0, source, start, temp.length);
    }

    public static void recursionMergeSort(int[] source, int start, int end){
        if (start >= end){
            return;
        }
        int midRoller = (start + end) >> 1;
        recursionMergeSort(source, start, midRoller);
        recursionMergeSort(source, midRoller + 1, end);
        doMerge(source, start, midRoller, end);
    }
}
----


== LeetCode题